<!DOCTYPE html>
<html>
<head>
 <link rel="stylesheet" href="minetest.css">
<head>
<body>
<p class="nav"><a href="index.html#contents">Contents</a>, <a href="full_index.html#Nodes">Index</a></p>
<h1 id="Nodes">Nodes</h1>
<p>
Nodes are the bulk data of the world: cubes and other things that take the space of a cube. Huge amounts of them are handled efficiently, but they are quite static.
</p>
<p>
The definition of a node is stored and can be accessed by using
</p>
&nbsp;&nbsp;&nbsp;&nbsp;minetest.registered_nodes[node.name]
<p>
See <a href="Registered_definitions.html#Registered definitions">Registered definitions</a>.
</p>
<p>
Nodes are passed by value between Lua and the engine. They are represented by a table:
</p>
&nbsp;&nbsp;&nbsp;&nbsp;{name="name", param1=num, param2=num}
<p>
<code>param1</code> and <code>param2</code> are 8-bit integers ranging from 0 to 255. The engine uses them for certain automated functions. If you don't use these functions, you can use them to store arbitrary values.
</p>
<h2 id="Node paramtypes">Node paramtypes</h2>
<p>
The functions of <code>param1</code> and <code>param2</code> are determined by certain fields in the node definition.
</p>
<p>
The function of <code>param1</code> is determined by <code>paramtype</code> in node definition. <code>param1</code> is reserved for the engine when <code>paramtype != "none"</code>.
</p>
<ul>
<li>
<code>paramtype = "light"</code>
<ul>
<li>
The value stores light with and without sun in its upper and lower 4 bits       respectively.
</li>
<li>
Required by a light source node to enable spreading its light.
</li>
<li>
Required by the following drawtypes as they determine their visual       brightness from their internal light value:
<ul>
<li>
torchlike
</li>
<li>
signlike
</li>
<li>
firelike
</li>
<li>
fencelike
</li>
<li>
raillike
</li>
<li>
nodebox
</li>
<li>
mesh
</li>
<li>
plantlike
</li>
<li>
plantlike_rooted
</li>
</ul>
</li>
</ul>
</li>
<li>
<code>paramtype = "none"</code>
<ul>
<li>
<code>param1</code> will not be used by the engine and can be used to store       an arbitrary value
<br>
The function of <code>param2</code> is determined by <code>paramtype2</code> in node definition.
<br>
<code>param2</code> is reserved for the engine when <code>paramtype2 != "none"</code>.
</li>
</ul>
</li>
<li>
<code>paramtype2 = "flowingliquid"</code>
<ul>
<li>
Used by <code>drawtype = "flowingliquid"</code> and <code>liquidtype = "flowing"</code>
</li>
<li>
The liquid level and a flag of the liquid are stored in <code>param2</code>
</li>
<li>
Bits 0-2: Liquid level (0-7). The higher, the more liquid is in this node;       see <code>minetest.get_node_level</code>, <code>minetest.set_node_level</code> and <code>minetest.add_node_level</code>       to access/manipulate the content of this field
</li>
<li>
Bit 3: If set, liquid is flowing downwards (no graphical effect)
</li>
</ul>
</li>
<li>
<code>paramtype2 = "wallmounted"</code>
<ul>
<li>
Supported drawtypes: "torchlike", "signlike", "normal", "nodebox", "mesh"
</li>
<li>
The rotation of the node is stored in <code>param2</code>
</li>
<li>
You can make this value by using <code>minetest.dir_to_wallmounted()</code>
</li>
<li>
Values range 0 - 5
</li>
<li>
The value denotes at which direction the node is "mounted":       0 = y+,   1 = y-,   2 = x+,   3 = x-,   4 = z+,   5 = z-
</li>
</ul>
</li>
<li>
<code>paramtype2 = "facedir"</code>
<ul>
<li>
Supported drawtypes: "normal", "nodebox", "mesh"
</li>
<li>
The rotation of the node is stored in <code>param2</code>. Furnaces and chests are       rotated this way. Can be made by using <code>minetest.dir_to_facedir()</code>.
</li>
<li>
Values range 0 - 23
</li>
<li>
facedir / 4 = axis direction:       0 = y+,   1 = z+,   2 = z-,   3 = x+,   4 = x-,   5 = y-
</li>
<li>
facedir modulo 4 = rotation around that axis
</li>
</ul>
</li>
<li>
<code>paramtype2 = "leveled"</code>
<ul>
<li>
Only valid for "nodebox" with 'type = "leveled"', and "plantlike_rooted".
<ul>
<li>
Leveled nodebox:
<ul>
<li>
The level of the top face of the nodebox is stored in <code>param2</code>.
</li>
<li>
The other faces are defined by 'fixed = {}' like 'type = "fixed"'               nodeboxes.
</li>
<li>
The nodebox height is (<code>param2</code> / 64) nodes.
</li>
<li>
The maximum accepted value of <code>param2</code> is 127.
</li>
</ul>
</li>
<li>
Rooted plantlike:
<ul>
<li>
The height of the 'plantlike' section is stored in <code>param2</code>.
</li>
<li>
The height is (<code>param2</code> / 16) nodes.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<code>paramtype2 = "degrotate"</code>
<ul>
<li>
Only valid for "plantlike" drawtype. The rotation of the node is stored in       <code>param2</code>.
</li>
<li>
Values range 0 - 179. The value stored in <code>param2</code> is multiplied by two to       get the actual rotation in degrees of the node.
</li>
</ul>
</li>
<li>
<code>paramtype2 = "meshoptions"</code>
<ul>
<li>
Only valid for "plantlike" drawtype. <code>param2</code> encodes the shape and       optional modifiers of the "plant". <code>param2</code> is a bitfield.
</li>
<li>
Bits 0 to 2 select the shape.       Use only one of the values below:
<ul>
<li>
0 = a "x" shaped plant (ordinary plant)
</li>
<li>
1 = a "+" shaped plant (just rotated 45 degrees)
</li>
<li>
2 = a "*" shaped plant with 3 faces instead of 2
</li>
<li>
3 = a "#" shaped plant with 4 faces instead of 2
</li>
<li>
4 = a "#" shaped plant with 4 faces that lean outwards
</li>
<li>
5-7 are unused and reserved for future meshes.
</li>
</ul>
</li>
<li>
Bits 3 to 7 are used to enable any number of optional modifiers.       Just add the corresponding value(s) below to <code>param2</code>:
<ul>
<li>
8  - Makes the plant slightly vary placement horizontally
</li>
<li>
16 - Makes the plant mesh 1.4x larger
</li>
<li>
32 - Moves each face randomly a small bit down (1/8 max)
</li>
<li>
values 64 and 128 (bits 6-7) are reserved for future use.
</li>
</ul>
</li>
<li>
Example: <code>param2 = 0</code> selects a normal "x" shaped plant
</li>
<li>
Example: <code>param2 = 17</code> selects a "+" shaped plant, 1.4x larger (1+16)
</li>
</ul>
</li>
<li>
<code>paramtype2 = "color"</code>
<ul>
<li>
<code>param2</code> tells which color is picked from the palette.       The palette should have 256 pixels.
</li>
</ul>
</li>
<li>
<code>paramtype2 = "colorfacedir"</code>
<ul>
<li>
Same as <code>facedir</code>, but with colors.
</li>
<li>
The first three bits of <code>param2</code> tells which color is picked from the       palette. The palette should have 8 pixels.
</li>
</ul>
</li>
<li>
<code>paramtype2 = "colorwallmounted"</code>
<ul>
<li>
Same as <code>wallmounted</code>, but with colors.
</li>
<li>
The first five bits of <code>param2</code> tells which color is picked from the       palette. The palette should have 32 pixels.
</li>
</ul>
</li>
<li>
<code>paramtype2 = "glasslikeliquidlevel"</code>
<ul>
<li>
Only valid for "glasslike_framed" or "glasslike_framed_optional"       drawtypes.
</li>
<li>
<code>param2</code> values 0-63 define 64 levels of internal liquid, 0 being empty       and 63 being full.
</li>
<li>
Liquid texture is defined using <code>special_tiles = {"modname_tilename.png"}</code>
</li>
</ul>
</li>
<li>
<code>paramtype2 = "none"</code>
<ul>
<li>
<code>param2</code> will not be used by the engine and can be used to store       an arbitrary value
<br>
Nodes can also contain extra data. See <a href="Metadata.html#Node Metadata">Node Metadata</a>.
</li>
</ul>
</li>
</ul>
<h2 id="Node drawtypes">Node drawtypes</h2>
<p>
There are a bunch of different looking node types.
</p>
<p>
Look for examples in <code>games/devtest</code> or <code>games/minetest_game</code>.
</p>
<ul>
<li>
<code>normal</code>
<ul>
<li>
A node-sized cube.
</li>
</ul>
</li>
<li>
<code>airlike</code>
<ul>
<li>
Invisible, uses no texture.
</li>
</ul>
</li>
<li>
<code>liquid</code>
<ul>
<li>
The cubic source node for a liquid.
</li>
</ul>
</li>
<li>
<code>flowingliquid</code>
<ul>
<li>
The flowing version of a liquid, appears with various heights and slopes.
</li>
</ul>
</li>
<li>
<code>glasslike</code>
<ul>
<li>
Often used for partially-transparent nodes.
</li>
<li>
Only external sides of textures are visible.
</li>
</ul>
</li>
<li>
<code>glasslike_framed</code>
<ul>
<li>
All face-connected nodes are drawn as one volume within a surrounding       frame.
</li>
<li>
The frame appearance is generated from the edges of the first texture       specified in <code>tiles</code>. The width of the edges used are 1/16th of texture       size: 1 pixel for 16x16, 2 pixels for 32x32 etc.
</li>
<li>
The glass 'shine' (or other desired detail) on each node face is supplied       by the second texture specified in <code>tiles</code>.
</li>
</ul>
</li>
<li>
<code>glasslike_framed_optional</code>
<ul>
<li>
This switches between the above 2 drawtypes according to the menu setting       'Connected Glass'.
</li>
</ul>
</li>
<li>
<code>allfaces</code>
<ul>
<li>
Often used for partially-transparent nodes.
</li>
<li>
External and internal sides of textures are visible.
</li>
</ul>
</li>
<li>
<code>allfaces_optional</code>
<ul>
<li>
Often used for leaves nodes.
</li>
<li>
This switches between <code>normal</code>, <code>glasslike</code> and <code>allfaces</code> according to       the menu setting: Opaque Leaves / Simple Leaves / Fancy Leaves.
</li>
<li>
With 'Simple Leaves' selected, the texture specified in <code>special_tiles</code>       is used instead, if present. This allows a visually thicker texture to be       used to compensate for how <code>glasslike</code> reduces visual thickness.
</li>
</ul>
</li>
<li>
<code>torchlike</code>
<ul>
<li>
A single vertical texture.
</li>
<li>
If placed on top of a node, uses the first texture specified in <code>tiles</code>.
</li>
<li>
If placed against the underside of a node, uses the second texture       specified in <code>tiles</code>.
</li>
<li>
If placed on the side of a node, uses the third texture specified in       <code>tiles</code> and is perpendicular to that node.
</li>
</ul>
</li>
<li>
<code>signlike</code>
<ul>
<li>
A single texture parallel to, and mounted against, the top, underside or       side of a node.
</li>
</ul>
</li>
<li>
<code>plantlike</code>
<ul>
<li>
Two vertical and diagonal textures at right-angles to each other.
</li>
<li>
See <code>paramtype2 = "meshoptions"</code> above for other options.
</li>
</ul>
</li>
<li>
<code>firelike</code>
<ul>
<li>
When above a flat surface, appears as 6 textures, the central 2 as       <code>plantlike</code> plus 4 more surrounding those.
</li>
<li>
If not above a surface the central 2 do not appear, but the texture       appears against the faces of surrounding nodes if they are present.
</li>
</ul>
</li>
<li>
<code>fencelike</code>
<ul>
<li>
A 3D model suitable for a wooden fence.
</li>
<li>
One placed node appears as a single vertical post.
</li>
<li>
Adjacently-placed nodes cause horizontal bars to appear between them.
</li>
</ul>
</li>
<li>
<code>raillike</code>
<ul>
<li>
Often used for tracks for mining carts.
</li>
<li>
Requires 4 textures to be specified in <code>tiles</code>, in order: Straight,       curved, t-junction, crossing.
</li>
<li>
Each placed node automatically switches to a suitable rotated texture       determined by the adjacent <code>raillike</code> nodes, in order to create a       continuous track network.
</li>
<li>
Becomes a sloping node if placed against stepped nodes.
</li>
</ul>
</li>
<li>
<code>nodebox</code>
<ul>
<li>
Often used for stairs and slabs.
</li>
<li>
Allows defining nodes consisting of an arbitrary number of boxes.
</li>
<li>
See <a href="Nodes.html#Node boxes">Node boxes</a> below for more information.
</li>
</ul>
</li>
<li>
<code>mesh</code>
<ul>
<li>
Uses models for nodes.
</li>
<li>
Tiles should hold model materials textures.
</li>
<li>
Only static meshes are implemented.
</li>
<li>
For supported model formats see Irrlicht engine documentation.
</li>
</ul>
</li>
<li>
<code>plantlike_rooted</code>
<ul>
<li>
Enables underwater <code>plantlike</code> without air bubbles around the nodes.
</li>
<li>
Consists of a base cube at the co-ordinates of the node plus a       <code>plantlike</code> extension above with a height of <code>param2 / 16</code> nodes.
</li>
<li>
The <code>plantlike</code> extension visually passes through any nodes above the       base cube without affecting them.
</li>
<li>
The base cube texture tiles are defined as normal, the <code>plantlike</code>       extension uses the defined special tile, for example:       <code>special_tiles = {{name = "default_papyrus.png"}},</code>
<br>
<code>*_optional</code> drawtypes need less rendering time if deactivated
<br>
(always client-side).
</li>
</ul>
</li>
</ul>
<h2 id="Node boxes">Node boxes</h2>
<p>
Node selection boxes are defined using "node boxes".
</p>
<p>
A nodebox is defined as any of:
</p>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- A normal cube; the default in most things
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = "regular"
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- A fixed box (or boxes) (facedir param2 is used, if applicable)
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = "fixed",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixed = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- A variable height box (or boxes) with the top face position defined
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- by the node parameter 'leveled = ', or if 'paramtype2 == "leveled"'
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- by param2.
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Other faces are defined by 'fixed = {}' as with 'type = "fixed"'.
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = "leveled",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixed = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- A box like the selection box for torches
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- (wallmounted param2 is used, if applicable)
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = "wallmounted",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wall_top = box,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wall_bottom = box,
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wall_side = box
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- A node that has optional boxes depending on neighbouring nodes'
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- presence and type. See also <code>connects_to</code>.
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type = "connected",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fixed = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect_top = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect_bottom = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect_front = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect_left = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect_back = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect_right = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- The following <code>disconnected_*</code> boxes are the opposites of the
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <code>connect_*</code> ones above, i.e. when a node has no suitable neighbour
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- on the respective side, the corresponding disconnected box is drawn.
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected_top = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected_bottom = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected_front = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected_left = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected_back = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected_right = box OR {box1, box2, ...}
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected = box OR {box1, box2, ...} -- when there is *no* neighbour
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected_sides = box OR {box1, box2, ...} -- when there are *no*
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- neighbours to the sides
<br>
&nbsp;&nbsp;&nbsp;&nbsp;}
<p>
A <code>box</code> is defined as:
</p>
&nbsp;&nbsp;&nbsp;&nbsp;{x1, y1, z1, x2, y2, z2}
<p>
A box of a regular node would look like:
</p>
&nbsp;&nbsp;&nbsp;&nbsp;{-0.5, -0.5, -0.5, 0.5, 0.5, 0.5},
<p>
To avoid collision issues, keep each value within the range of +/- 1.45. This also applies to leveled nodeboxes, where the final height shall not exceed this soft limit.
</p>
<p class="nav"><a href="index.html#contents">Contents</a>, <a href="full_index.html#Nodes">Index</a></p>
<br>
</body>
</html>
